// cli1 - Minimal command-line Black Friday program
// Example front-end for command-line use
// Most stripped-down possible input. Give it a
// markdown file and the name of an output HTML file,
// and it generates that HTML file from the markup.

// Example:
// ./cli1 foo.md foo.html
//
package main

import (
	"fmt"
	"github.com/russross/blackfriday"
	"io/ioutil"
	"os"
)

// Given the name of an input Markdown file and the name of
// an output HTML file, generate HTML from the input file
// and create the HTML file. Does not check to see if an existing
// HTML file exists. title gets passed as the title tag,
// and css is a placeholder that doesn't get used in this
// program.
//
func generateHTML(infile string, outfile string, title string, css string) (err error) {
	var input []byte
	// Read the markdown file into a byte slice.
	if input, err = ioutil.ReadFile(infile); err != nil {
		return err
	}
	// Create an object to do the rendering.
	// Pass it the contents of a title tag, and CSS
	// (which in this case isn't used)
	renderer := blackfriday.HtmlRenderer(blackfriday.HTML_COMPLETE_PAGE,
		title, css)

	// Read the markdown file from the byte slice named
	// input, render to HTML, and write
	// to a byte slice named output.
	var output []byte
	output = blackfriday.Markdown(input, renderer, 0)

	// Take the rendered HTML and open up a file object.
	var out *os.File
	if out, err = os.Create(outfile); err != nil {
		return err
	}
	defer out.Close()

	// Take the generated byte slice in output and
	// create an HTML file.
	if _, err = out.Write(output); err != nil {
		return err
	}

	// Success.
	return nil
}

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintln(os.Stderr,
			"Please specify 2 filenames: the first is a markdown file, the second is an HTML output file.")
		os.Exit(-1)
	}
	if err := generateHTML(os.Args[1], os.Args[2], "Markdown!", ""); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err.Error())
	}
}
